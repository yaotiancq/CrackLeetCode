###############################################################################################################################################
######################### Snapsack prpblem ####################################################################################################
###############################################################################################################################################
                  |--> (snapsack) --> (max capacity v)
                  |
                  |
                  |
snapsack problem -|
                  |                                                                 |--> (chosen) -------|
                  |                                            |--> (only 1 item) --|                    |--> (0/1 Snapsack Problem)
                  |               |--> (value w)               |                    |--> (not chosen) ---|
                  |--> (item) --> |--> (volume v)              |                 |--> (not chosen) ------|
                                  |--> (number of each item) --|--> (infinite) --|                       |--> (Complete Knapsack Problem/Unbounded Knapsack Problem)
                                                               |                 |--> (choose several)---|
                                                               |--> (different item has different number)---> (Multiple Knapsack Problem/Multi-dimensional Knapsack Problem)
                                                               |--> (group packing, at most one item per group)--> (Grouped Knapsack Problem/Knapsack Problem with Group Constraints)


0/1 snapsack problem

    416. Partition Equal Subset Sum 
        --- Given the capacity of snapsack, want to know weigher the candidates can exactly fill the snapsack. dp[-1]==target
    1049. Last Stone Weight 2 
        --- Given the capacity of snapsack, want to know the remain capacity of snapsack when trying to fill item in snapsack as more as possible.
    494. Target Sum 
        --- Given the capacity of snapsack, want to know the number of combinations of exact filling the snapsack. 
        --- The sum of positive number can be calculated.
        --- The deduction relationship is: dp[j]+=dp[j-nums[i]], each number in nums provide one possibility.
        --- dp[0]=1, other initial value is 0, we need to deduct from 0, so it must be 1, not every numer in nums needed to be choosen, so its' initial value must be 0
    474. Ones and Zeroes
        --- Given the capacity of snapsack, want to know the maximum length of choosen item list, each item has mutilple attributes.
        --- For mutiple dimension 0/1 snapsack problem, we need mutiple dimension DP array to equally deal with multiple attributes.
        --- The deduction relationship is: dp[i][j]=max(dp[i][j], dp[i-item[0]][j-item[1]])+value[i]

Unbounded snapsack problem

    518. Coin Change 2
        --- Given the capacity of snapsack, want to know the number of combinations of exact filling the snapsack.
        --- Can use unlimited number of each of candidates. So, it is a unbounded snapsack problem.
    377. Combination Sum 4
        --- Given the capacity of snapsack, can use unlimited number of each of candidates.
        --- Need to know the number of all permutations.
        --- First capacity loop, then item loop, will generate permutations.
    70. Climbing Stairs
        --- Given the capacity of snapsack, that is the n stairs. Candidates=[1,2], that is 1 or 2 steps at a time. Unlimited number of each of candidates.
        --- First 1 then 2 and first 2 then 1 are different ways to reach top. So, we need to know the number of permutations.
    322. Coin Change
        --- Given the capacity of snapsack, Unlimited number of each of candidates.
        --- Minimal count of answer. So, that is the length of chosen candidates. dp[j]=min(dp[j],dp[j-candidate[i]]+1)
    279. Perfect Squares
        --- Given the capacity of snapsack, unliminted number of each candidates.
        --- Minnimal count of answer. dp[j] = min(dp[j - i * i] + 1, dp[j])
    139. Word Break
        --- Given the capacity of snapsack, unliminted number of each candidates.
        --- String assembly is not like sum of numbers. It can not ignore the order of word. So, it is permutation, combinations might not work in most of cases.
            That means we need capacity loop first. It also can not allow assembly when the word is not we want, so, we need check whether the word is our target
            word in string.

Multiple Knapsack Problem
    The only difference between Multiple Knapsack Problem and 0/1 Knapsack Problem is that the Multiple Knapsack Problem has more than one in number of same candidate.
We just span the candidates. Making the candidate which is more than one a 0/1 candidates but showing multiple times in candidates. So, our problem is turning to 0/1
snapsack problem.

###################################################################################################################################################
##################### Best time to buy and sell stock proplem #####################################################################################
###################################################################################################################################################
Best time to buy and sell stock proplem
    121. Best time to buy and sell stock
        --- buy and sell stock only once.
        --- 2 status: hold stock, don't hold stock dp[i][0], dp[i][1]
        --- When buy stock, the previous day's profit when don't hold stock must be 0
    122. Best time to buy and sell stock II
        --- buy and sell stock unlimited times.
        --- 2 status: hold stock, don't hold stock
        --- When buy stock ,the previous day's profit must be remained
    123. Best time to buy and sell stock III
        --- buy and sell stock at most 2 times.
        --- 5 status: no operations, fisrt hold stock, first don't hold stock, second hold stock, second don't hold stock
        --- When buy stock ,the previous day's profit must be remained
    188. Best time to buy and sell stock IV
        --- buy and sell stock at most k times.
        --- 2k+1 status: no operations, fisrt hold stock, first don't hold stock,..., k-th hold stock, k-th don't hold stock
        --- When buy stock ,the previous day's profit must be remained
    309. Best time to buy and sell stock with cool down
        --- buy and sell stock unlimited times, but need to cool down one day after every stock selling.
        --- 4 status: hold stock, don't hold stock(sell stock day, cool down day, ready to buy but not in cool down day)
        --- This clasification help cool down day refer to a one day before status, help clearly classified status.
        --- When buy stock ,the previous day's profit must be remained
    714. Best time to buy and sell stock with transaction fee
        --- buy and sell stock unlimited times
        --- 2 status: hold stock, don't hold stock
        --- Every sell have to pay fee


